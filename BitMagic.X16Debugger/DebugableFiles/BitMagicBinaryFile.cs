using BitMagic.Common;
using BitMagic.Common.Address;
using BitMagic.Compiler;
using BitMagic.X16Emulator;
using Microsoft.CodeAnalysis;

namespace BitMagic.X16Debugger.DebugableFiles;

public enum FileHeader
{
    NoHeader,
    HeaderInCode,
    HeaderNotInCode
}

/// <summary>
/// Binary file that has been generated by the compiler.
/// Includes debugging extensions
/// </summary>
internal class BitMagicBinaryFile : SourceFileBase, IBinaryFile
{
    public IReadOnlyList<byte> Data { get; }
    public IReadOnlyList<uint> DebugData { get; }
    public int BaseAddress { get; private set; }
    public override bool X16File => true;


    private readonly Dictionary<int, string> _symbols = new Dictionary<int, string>();
    public IReadOnlyDictionary<int, string> Symbols => _symbols;

    public override IReadOnlyList<string> Content { get; protected set; } = Array.Empty<string>();

    private readonly List<ISourceFile> _parents = new List<ISourceFile>();
    public override IReadOnlyList<ISourceFile> Parents => _parents;
    private readonly ParentSourceMapReference[] _parentMap;
    public override IReadOnlyList<ParentSourceMapReference> ParentMap => _parentMap;

    private readonly CompileResult _result;
    public FileHeader HasHeader { get; }

    public bool Written { get; private set; }

    /// <summary>
    /// A binary file from a BitMagic project
    /// </summary>
    /// <param name="source">SourceFile</param>
    /// <param name="stream">Data stream for binary</param>
    /// <param name="result">Compile result</param>
    /// <param name="hasHeader">Header type if any</param>
    internal BitMagicBinaryFile(SourceFileBase source, NamedStream stream, CompileResult result, FileHeader hasHeader)
    {
        Origin = SourceFileType.Binary;
        ActualFile = false; // this is for source files?
        Name = System.IO.Path.GetFileName(stream.FileName).ToUpper();
        Path = stream.FileName.ToUpper();
        Data = stream.ToArray();
        DebugData = stream.DebugData;
        _parents.Add(source);
        HasHeader = hasHeader;
        _parentMap = new ParentSourceMapReference[Data.Count - (HasHeader == FileHeader.NoHeader ? 0 : 2)]; // if there is a header, then the first byte bytes aren't loaded into memory
        _result = result;

        for (var i = 0; i < _parentMap.Length; i++)
        {
            _parentMap[i] = new ParentSourceMapReference(-1, -1);
        }

        source.AddChild(this);
        CreateChildMap();
    }

    private void CreateChildMap()
    {
        var state = _result.State;

        var segment = state.Segments.Values.FirstOrDefault(i => string.Equals(i.Filename, Name, StringComparison.InvariantCultureIgnoreCase));

        if (segment != null) // error condition?
        {
            BaseAddress = segment.StartAddress;

            foreach (var defaultProc in segment.DefaultProcedure.Values)
            {
                MapProcForParents(defaultProc);
            }
        }

        foreach (var (name, value) in _result.State.ScopeFactory.GlobalVariables.GetChildVariables("App"))
        {
            if (!Symbols.ContainsKey(value.Value))
                _symbols.Add(value.Value, name);
        }
    }

    /// <summary>
    /// Map a procedure to the memory location.
    /// ParentMap is an array of the length of the binary file.
    /// </summary>
    /// <param name="proc"></param>
    private void MapProcForParents(Procedure proc)
    {
        foreach (var line in proc.Data)
        {
            // all lines go to the parent, as thats the generated code
            var offset = line.Address - BaseAddress - (HasHeader == FileHeader.HeaderInCode ? 2 : 0);
            if (offset < 0)
                continue; // dont map code that creates the header

            _parentMap[offset] = new ParentSourceMapReference(line.Source.LineNumber - 1, 0); // this is zero based
        }

        foreach (var p in proc.Procedures)
            MapProcForParents(p);
    }


    /// <summary>
    /// Map the file to the source map for the stack, called in the binary file load in the DebugWrapper.
    /// </summary>
    /// <param name="emulator"></param>
    private void MapProcToMemory(Emulator emulator, SourceMapManager sourceMapManager)
    {
        var state = _result.State;

        var segment = state.Segments.Values.FirstOrDefault(i => string.Equals(i.Filename, Name, StringComparison.InvariantCultureIgnoreCase));

        if (segment != null) // error condition?
        {
            foreach (var defaultProc in segment.DefaultProcedure.Values)
            {
                MapProcToMemory(defaultProc, emulator, sourceMapManager);
            }
        }

    }

    private void MapProcToMemory(Procedure proc, Emulator emulator, SourceMapManager sourceMapManager)
    {
        foreach (var line in proc.Data)
        {
            // need to store the memory to line in the file lookup, which is used by the stack code
            var debuggerAddress = AddressFunctions.GetDebuggerAddress(line.Address, emulator);

            sourceMapManager.AddSourceMap(debuggerAddress, line);
        }

        foreach (var p in proc.Procedures)
            MapProcToMemory(p, emulator, sourceMapManager);
    }

    public override Task UpdateContent() => Task.CompletedTask;

    public void LoadDebugData(Emulator emulator, SourceMapManager sourceMapManager, int debuggerAddress)
    {
        MapProcToMemory(emulator, sourceMapManager); // map bitmagic lines to the sourecmap for the stack

        if (!DebugData.Any())
            return;

        for (var i = 0; i < DebugData.Count; i++)
        {
            var (address, ramBank, romBank) = AddressFunctions.GetMachineAddress(debuggerAddress);
            var (offset, secondOffset) = AddressFunctions.GetMemoryLocations(ramBank > 0 ? ramBank : romBank, address);

            emulator.Breakpoints[offset] |= DebugData[i];
            if (secondOffset != 0)
                emulator.Breakpoints[secondOffset] |= DebugData[i];

            debuggerAddress = AddressFunctions.IncrementDebuggerAddress(debuggerAddress);
        }
    }

    public void Relocate(int newBaseAddress)
    {
        var segment = _result.State.Segments.Values.FirstOrDefault(i => string.Equals(i.Filename, Name, StringComparison.InvariantCultureIgnoreCase));

        if (segment != null) // error condition?
        {
            var delta = newBaseAddress - BaseAddress;
            BaseAddress = newBaseAddress;

            segment.StartAddress += delta;

            foreach (var defaultProc in segment.DefaultProcedure.Values)
            {
                defaultProc.Relocate(delta);
            }

            //foreach (var defaultProc in segment.DefaultProcedure.Values)
            //{
            //    MapProcForParents(defaultProc);
            //}
        }
    }

    public void SetWritten()
    {
        Written = true;
    }
}
