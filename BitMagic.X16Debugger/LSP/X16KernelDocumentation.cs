using System.Text.Json;

namespace BitMagic.X16Debugger.LSP;

internal class X16KernelDocumentation : TokenDescriptionProvider
{
    public X16KernelDocumentation()
    {
        Process(JsonSerializer.Deserialize<Dictionary<string, string>>("{\"ACPTR\":\"**ACPTR**\\r\\n\\r\\nPurpose: Read a byte from the peripheral bus  \\r\\nCall address: $FFA5  \\r\\nCommunication registers: .A  \\r\\nPreparatory routines: \\u0060SETNAM\\u0060, \\u0060SETLFS\\u0060, \\u0060OPEN\\u0060, \\u0060CHKIN\\u0060  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y .P  \\r\\n\\r\\n**Description:** This routine gets a byte of data off the peripheral bus. The data is returned in the accumulator.  Errors are returned in the status word which can be read via the \\u0060READST\\u0060 API call.\\r\\n\\r\\n\",\"MACPTR\":\"**MACPTR**\\r\\n\\r\\nPurpose: Read multiple bytes from the peripheral bus  \\r\\nCall address: $FF44  \\r\\nCommunication registers: .A .X .Y c  \\r\\nPreparatory routines: \\u0060SETNAM\\u0060, \\u0060SETLFS\\u0060, \\u0060OPEN\\u0060, \\u0060CHKIN\\u0060  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** The routine \\u0060MACPTR\\u0060 is the multi-byte variant of the \\u0060ACPTR\\u0060 KERNAL routine. Instead of returning a single byte in .A, it can read multiple bytes in one call and write them directly to memory.\\r\\n\\r\\nThe number of bytes to be read is passed in the .A register; a value of 0 indicates that it is up to the KERNAL to decide how many bytes to read - up to a maximum of 512 bytes (this corresponds to 1 sector on the SD card). A pointer to where the data is supposed to be written is passed in the .X (lo) and .Y (hi) registers. If carry flag is clear, the destination address will advance with each byte read. If the carry flag is set, the destination address will not advance as data is read. This is useful for reading data directly into VRAM, PCM FIFO, etc.\\r\\n\\r\\nFor reading into Hi RAM, you must set the desired bank prior to calling \\u0060MACPTR\\u0060. During the read, \\u0060MACPTR\\u0060 will automatically wrap to the next bank as required, leaving the new bank active when finished.\\r\\n\\r\\nUpon return, a set c flag indicates that the device or file does not support \\u0060MACPTR\\u0060, and the program needs to read the data byte-by-byte using the \\u0060ACPTR\\u0060 call instead.\\r\\n\\r\\nIf \\u0060MACPTR\\u0060 is supported, c is clear and .X (lo) and .Y (hi) contain the number of bytes read.\\r\\n*It is possible that this is less than the number of bytes requested to be read! (But is always greater than 0)*\\r\\n\\r\\nLike with \\u0060ACPTR\\u0060, the status of the operation can be retrieved using the \\u0060READST\\u0060 KERNAL call.\\r\\n\\r\\n\",\"MCIOUT\":\"**MCIOUT**\\r\\n\\r\\nPurpose: Write multiple bytes to the peripheral bus  \\r\\nCall address: $FEB1  \\r\\nCommunication registers: .A .X .Y c  \\r\\nPreparatory routines: \\u0060SETNAM\\u0060, \\u0060SETLFS\\u0060, \\u0060OPEN\\u0060, \\u0060CHKOUT\\u0060  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** The routine \\u0060MCIOUT\\u0060 is the multi-byte variant of the \\u0060CIOUT\\u0060 KERNAL routine. Instead of writing a single byte, it can write multiple bytes from memory in one call.\\r\\n\\r\\nThe number of bytes to be written is passed in the .A register; a value of 0 indicates 256 bytes. A pointer to the data to be read from is passed in the .X (lo) and .Y (hi) registers. If carry flag is clear, the source address will advance with each byte read out. If the carry flag is set, the source address will not advance as data is read out. This is useful for saving data directly from VRAM.\\r\\n\\r\\nFor reading from Hi RAM, you must set the desired bank prior to calling \\u0060MCIOUT\\u0060. During the operation, \\u0060MCIOUT\\u0060 will automatically wrap to the next bank as required, leaving the new bank active when finished.\\r\\n\\r\\nUpon return, a set c flag indicates that the device or file does not support \\u0060MCIOUT\\u0060, and the program needs to write the data byte-by-byte using the \\u0060CIOUT\\u0060 call instead.\\r\\n\\r\\nIf \\u0060MCIOUT\\u0060 is supported, c is clear and .X (lo) and .Y (hi) contain the number of bytes written.\\r\\n*It is possible that this is less than the number of bytes requested to be written! (But is always greater than 0)*\\r\\n\\r\\nLike with \\u0060CIOUT\\u0060, the status of the operation can be retrieved using the \\u0060READST\\u0060 KERNAL call.  If an error occurred, \\u0060READST\\u0060 should return nonzero.\\r\\n\\r\\n\",\"BSAVE\":\"**BSAVE**\\r\\n\\r\\nPurpose: Save an area of memory to a file without writing an address header.  \\r\\nCall Address: $FEBA  \\r\\nCommunication Registers: .A .X .Y  \\r\\nPreparatory routines: SETNAM, SETLFS  \\r\\nError returns: c = 0 if no error, c = 1 in case of error and A will contain kernel error code  \\r\\nRegisters affected: .A .X .Y .P  \\r\\n\\r\\n**Description:** Save the contents of a memory range to a file.  Unlike \\u0060SAVE\\u0060, this call does not write the start address to the beginning of the output file.\\r\\n\\r\\n\\u0060SETLFS\\u0060 and \\u0060SETNAM\\u0060 must be called beforehand.  \\r\\nA is address of zero page pointer to the start address.  \\r\\nX and Y contain the _exclusive_ end address to save. That is, these should contain the address immediately after the final byte:  X = low byte, Y = high byte.  \\r\\nUpon return, if C is clear, there were no errors.  C being set indicates an error in which case A will have the error number.  \\r\\n\\r\\n\",\"BSOUT\":\"**BSOUT**\\r\\n\\r\\n(This routine is also referred to as \\u0060CHROUT\\u0060)  \\r\\n\\r\\nPurpose: Write a character to the default output device.  \\r\\nCall Address: $FFD2  \\r\\nCommunication Register: .A  \\r\\nPreparatory routines: OPEN, CHKOUT (Both are only needed when sending to files/other non-screen devices)  \\r\\nError returns: c = 0 if no error, c = 1 in case of error  \\r\\nRegisters affected: .P  \\r\\n\\r\\n**Description:** Writes the character in A to the currently-selected output device. By default, this is the user\\u0027s screen. By calling \\u0060CHKOUT\\u0060, however, the default device can be changed and characters can be sent to other devices - a file on an SD card, for example. In order to send output to a file, call \\u0060OPEN\\u0060 first to open the file, then \\u0060CHKOUT\\u0060 to set it as the default output device, then finally \\u0060BSOUT\\u0060 to write the data.  \\r\\n\\r\\nUpon return, if C is clear, there were no errors. Otherwise, C will be set.  \\r\\n\\r\\n**Note:** Before returning, this routine uses a \\u0060CLI\\u0060 processor instruction, which will allow IRQ interrupts to be triggered. This makes the \\u0060BSOUT\\u0060 routine inappropriate for use within interrupt handler functions. One possible workaround could be to output text information directly, by writing to the appropriate VERA registers. Care must be taken to save and restore the VERA\\u0027s state, however, in order to prevent affecting other software running on the system (to include BASIC or the KERNAL itself).  \\r\\n\\r\\n\",\"CLOSE\":\"**CLOSE**\\r\\n\\r\\nPurpose: Close a logical file  \\r\\nCall address: $FFC3  \\r\\nCommunication registers: .A  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y .P  \\r\\n\\r\\n**Description:** \\u0060CLOSE\\u0060 releases resources associated with a logical file number.  If the associated device is a serial device on the IEC bus or is a simulated serial device such as CMDR-DOS backed by the X16 SD card, and the file was opened with a secondary address, a close command is sent to the device or to CMDR-DOS.  \\r\\n\\r\\n\",\"CHKIN\":\"**CHKIN**\\r\\n\\r\\nPurpose: Set file to be used for character input  \\r\\nCall address: $FFC6  \\r\\nCommunication registers: .X  \\r\\nPreparatory routines: OPEN  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X\\r\\n\\r\\n**Description:** \\u0060CHKIN\\u0060 sets a file to be used as default input allowing for\\r\\nsubsequent calls to \\u0060CHRIN\\u0060 or other file read functions. The \\u0060x\\u0060 register\\r\\nshould contain the logical file number. \\u0060OPEN\\u0060 will need to have been called prior to using \\u0060CHKIN\\u0060.\\r\\n\\r\\n\",\"LOAD\":\"**LOAD**\\r\\n\\r\\nPurpose: Load the contents of a file from disk to memory  \\r\\nCall address: $FFD5  \\r\\nCommunication registers: .A .X .Y  \\r\\nPreparatory routines: SETNAM, SETLFS  \\r\\nError returns: Carry (Set on Error), .A  \\r\\nRegisters affected: .A .X .Y .P  \\r\\n\\r\\n**Description:** Loads a file from disk to memory.\\r\\n\\r\\nThe behavior of \\u0060LOAD\\u0060 can be modified by parameters passed to prior call to \\u0060SETLFS\\u0060.  In particular, the .Y register, which usually denotes the _secondary address_, has a specific meaning as follows:\\r\\n\\r\\n* .Y = 0: load to the address given in .X/.Y to the \\u0060LOAD\\u0060 call, skipping the first two bytes of the file. (like \\u0060LOAD \\u0022FILE\\u0022,8\\u0060 in BASIC)\\r\\n* .Y = 1: load to the address given by the first two bytes of the file. The address in .X/.Y is ignored. (like \\u0060LOAD \\u0022FILE\\u0022,8,1\\u0060 in BASIC)\\r\\n* .Y = 2: load the entire file to the address given in .X/.Y to the \\u0060LOAD\\u0060 call. This is also known as a _headerless_ load. (like \\u0060BLOAD \\u0022FILE\\u0022,8,1,$A000\\u0060 in BASIC)\\r\\n\\r\\nFor the \\u0060LOAD\\u0060 call itself, .X and .Y is the memory address to load\\r\\nthe file into. .A controls where the file is to be loaded. On the X16, \\u0060LOAD\\u0060 has an\\r\\nadditional feature to load the contents of a file directly into VRAM.\\r\\n\\r\\n* If the A register is zero, the kernal loads into system memory.\\r\\n* If the A register is 1, the kernal performs a verify.\\r\\n* If the A register is 2, the kernal loads into VRAM, starting from $00000 \\u002B the specified starting address.\\r\\n* If the A register is 3, the kernal loads into VRAM, starting from $10000 \\u002B the specified starting address.\\r\\n\\r\\n(On the C64, if A is greater than or equal to 1, the kernal performs a verify)\\r\\n\\r\\nFor loads into the banked RAM area. The current RAM bank (in location \\u0060$00\\u0060) is used as the start point for the load along with the supplied address. If the load is large enough to advance to the end of banked RAM (\\u0060$BFFF\\u0060), the RAM bank is automatically advanced, and the load continues into the next bank starting at \\u0060$A000\\u0060.\\r\\n\\r\\nAfter the load, if c is set, an error occurred and .A will contain the error code. If c is clear, .X/.Y will point to the address of final byte loaded \\u002B 1.\\r\\n\\r\\nNote: One does not need to call \\u0060CLOSE\\u0060 after \\u0060LOAD\\u0060.\\r\\n\\r\\n\",\"OPEN\":\"**OPEN**\\r\\n\\r\\nPurpose: Opens a channel/file  \\r\\nCall address: $FFC0  \\r\\nCommunication registers: None  \\r\\nPreparatory routines: SETNAM, SETLFS  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** Opens a file or channel.  \\r\\nThe most common pattern is to then redirect the standard input or output to the file using \\u0060CHKIN\\u0060 or \\u0060CHKOUT\\u0060 respectively. Afterwards, I/O from or to the file or channel is done using \\u0060BASIN\\u0060 (\\u0060CHRIN\\u0060) and \\u0060BSOUT\\u0060 (\\u0060CHROUT\\u0060) respectively.\\r\\n\\r\\nFor file I/O, the lower level calls \\u0060ACPTR\\u0060 and \\u0060MACPTR\\u0060 can be used in place of \\u0060CHRIN\\u0060, since \\u0060CHKIN\\u0060 does the low-level setup for this.  Likewise \\u0060CIOUT\\u0060 and \\u0060MCIOUT\\u0060 can be used after \\u0060CHKOUT\\u0060 for the same reason.\\r\\n\\r\\n\",\"SAVE\":\"**SAVE**\\r\\n\\r\\nPurpose: Save an area of memory to a file.  \\r\\nCall Address: $FFD8  \\r\\nCommunication Registers: .A .X .Y  \\r\\nPreparatory routines: SETNAM, SETLFS  \\r\\nError returns: c = 0 if no error, c = 1 in case of error and A will contain kernel error code  \\r\\nRegisters affected: .A .X .Y .P  \\r\\n\\r\\n**Description:** Save the contents of a memory range to a file. The (little-endian) start address is written to the file as the first two bytes of output, followed by the requested data.\\r\\n\\r\\n\\u0060SETLFS\\u0060 and \\u0060SETNAM\\u0060 must be called beforehand.  \\r\\nA is address of zero page pointer to start address.  \\r\\nX = low byte of end address \\u002B 1, Y = high byte of end address.  \\r\\nIf C is zero there were no errors; 1 is an error in which case A will have the error  \\r\\n\\r\\n\",\"SETLFS\":\"**SETLFS**\\r\\n\\r\\nPurpose: Set file parameters  \\r\\nCall Address: $FFBA  \\r\\nCommunication Registers: .A .X .Y  \\r\\nPreparatory routines: SETNAM  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** Set file parameters typically after calling SETNAM\\r\\n\\r\\nA is the logical file number, X is the device number, and Y is the secondary address.\\r\\n\\r\\nSince multiple files can be open (with some exceptions), the value of A specifies the file\\r\\nnumber. If only one file is being opened at a time, $01 can be used.\\r\\n\\r\\nThe device number corresponds to the hardware device where the file lives. On the X16,\\r\\n$08 would be the SD card.\\r\\n\\r\\nThe secondary address has some special meanings:  \\r\\n\\r\\nWhen used with \\u0060OPEN\\u0060 on disk type devices, the following applies:  \\r\\n\\r\\n* 0 = Load (open for read)\\r\\n* 1 = Save (open for write)\\r\\n* 2-14 = Read mode, by default. Write, Append, and Modify modes can be specified in the SETNAM filename string as the third argument, e.g. \\u0060\\u0022FILE.DAT,S,W\\u0022\\u0060 for write mode. The seek command \\u0022P\\u0022 is available in any mode.\\r\\n* 15 = Command Channel (for sending special commands to CMDR-DOS or the disk device)\\r\\n\\r\\nWhen used with \\u0060LOAD\\u0060 the following applies:\\r\\n\\r\\n* 0 = Load the data to address specified in the X and Y register of the LOAD call, regardless of the address header. The two-byte header itself is not loaded into RAM.\\r\\n* 1 = Load to the address specified in the file\\u0027s header. The two-byte header itself is not loaded into RAM.\\r\\n* 2 = Load the data to address specified in the X and Y register of the LOAD call. The entire file is loaded (\\u0022headerless\\u0022).\\r\\n\\r\\nFor more information see [Chapter 13: Working with CMDR-DOS](X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS.md#chapter-13-working-with-cmdr-dos)\\r\\n\\r\\n\",\"SETNAM\":\"**SETNAM**\\r\\n\\r\\nPurpose: Set file name  \\r\\nCall Address: $FFBD  \\r\\nCommunication Registers: .A .X .Y  \\r\\nPreparatory routines: SETLFS  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** Inform the kernal the name of the file that is to later be opened.\\r\\n A is filename length, X is low byte of filename pointer, Y is high byte of filename pointer.\\r\\n\\r\\nFor example:\\r\\n\\r\\n\\u0060\\u0060\\u0060asm\\r\\n  lda #$08\\r\\n  ldx #\\u003Cfilename\\r\\n  ldy #\\u003Efilename\\r\\n  jsr SETNAM\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\\u0060SETLFS\\u0060 and \\u0060SETNAM\\u0060 both need to be called prior other file comamnds, such as \\u0060OPEN\\u0060 or\\r\\n\\u0060SAVE\\u0060.\\r\\n\\r\\nTo append to a file, add \\u0060,?,A\\u0060 to the filename. See [Appending to file](X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS.md#appending-to-file).\\r\\n\\r\\n**Warning:** Appending to file involves a risk of corrupting the file system of the SD card! See [Appending to file](X16%20Reference%20-%2013%20-%20Working%20with%20CMDR-DOS.md#appending-to-file).\\r\\n\\r\\n\",\"memory_fill\":\"**memory_fill**\\r\\n\\r\\nSignature: void memory_fill(word address: r0, word num_bytes: r1, byte value: .A);  \\r\\nPurpose: Fill a memory region with a byte value.  \\r\\nCall address: $FEE4\\r\\n\\r\\n**Description:** This function fills the memory region specified by an address (r0) and a size in bytes (r1) with the constant byte value passed in .A. r0 and .A are preserved, r1 is destroyed.\\r\\n\\r\\nIf the target address is in the \\\\$9F00-\\\\$9FFF range, all bytes will be written to the same address (r0), i.e. the address will not be incremented. This is useful for filling VERA memory (\\\\$9F23 or \\\\$9F24), for example.\\r\\n\\r\\n\",\"memory_copy\":\"**memory_copy**\\r\\n\\r\\nSignature: void memory_copy(word source: r0, word target: r1, word num_bytes: r2);  \\r\\nPurpose: Copy a memory region to a different region.  \\r\\nCall address: $FEE7\\r\\n\\r\\n**Description:** This function copies one memory region specified by an address (r0) and a size in bytes (r2) to a different region specified by its start address (r1). The two regions may overlap. r0 and r1 are preserved, r2 is destroyed.\\r\\n\\r\\nLike with \\u0060memory_fill\\u0060, source and destination addresses in the \\\\$9F00-\\\\$9FFF range will not be incremented during the copy. This allows, for instance, uploading data from RAM to VERA (destination of \\\\$9F23 or \\\\$9F24), downloading data from VERA (source \\\\$9F23 or \\\\$9F24) or copying data inside VERA (source \\\\$9F23, destination \\\\$9F24). This functionality can also be used to upload, download or transfer data with other I/O devices that have an 8 bit data port.\\r\\n\\r\\n\",\"memory_crc\":\"**memory_crc**\\r\\n\\r\\nSignature: (word result: r2) memory_crc(word address: r0, word num_bytes: r1);  \\r\\nPurpose: Calculate the CRC16 of a memory region.  \\r\\nCall address: $FEEA\\r\\n\\r\\n**Description:** This function calculates the CRC16 checksum ([CRC-16/IBM-3740](https://www.crccalc.com/?crc=01%2002%2003%2004\\u0026method=CRC-16/IBM-3740\\u0026datatype=hex\\u0026outtype=hex)) of the memory region specified by an address (r0) and a size in bytes (r1). The result is returned in r2. r0 is preserved, r1 is destroyed.\\r\\n\\r\\nLike \\u0060memory_fill\\u0060, this function does not increment the address if it is in the range of \\\\$9F00-\\\\$9FFF, which allows checksumming VERA memory or data streamed from any other I/O device.\\r\\n\\r\\nNote: ROM R48 and older contains the following bug: If the size of the data is not a multiple of 256, the remainder of the data is processed in the wrong byte order. This bug was fixed in [#382](https://github.com/X16Community/x16-rom/pull/382). Thus, if your data is not a multiple of 256, you will get different CRC depending of ROM version.\\r\\n\\r\\n\",\"memory_decompress\":\"**memory_decompress**\\r\\n\\r\\nSignature: void memory_decompress(word input: r0, inout word output: r1);  \\r\\nPurpose: Decompress an LZSA2 block  \\r\\nCall address: $FEED\\r\\n\\r\\n**Description:** This function decompresses an LZSA2-compressed data block from the location passed in r0 and outputs the decompressed data at the location passed in r1. After the call, r1 will be updated with the location of the last output byte plus one.\\r\\n\\r\\nIf the target address is in the \\\\$9F00-\\\\$9FFF range, all bytes will be written to the same address (r0), i.e. the address will not be incremented. This is useful for decompressing directly into VERA memory (\\\\$9F23 or \\\\$9F24), for example. Note that decompressing _from_ I/O is not supported.\\r\\n\\r\\n**Notes**:\\r\\n\\r\\n* To create compressed data, use the \\u0060lzsa\\u0060 tool[^1] like this:\\r\\n\\u0060lzsa -r -f2 \\u003Coriginal_file\\u003E \\u003Ccompressed_file\\u003E\\u0060\\r\\n* If using the LZSA library to compress data, make sure to use format 2 and include the raw blocks flag, which is what the above command does.\\r\\n* This function cannot be used to decompress data in-place, as the output data would overwrite the input data before it is consumed. Therefore, make sure to load the input data to a different location.\\r\\n* It is possible to have the input data stored in banked RAM, with the obvious 8 KB size restriction.\\r\\n* When decompressing to VRAM, it\\u0027s reccomended to do that through \\u0060DATA0\\u0060.\\r\\n* If you\\u0027d like to have control of how the LZSA2 data is obtained, check out the [\\u0060memory_decompress_from_func\\u0060](#extapi-function-name-memory_decompress_from_func) function.\\r\\n\\r\\n\",\"fetch\":\"**fetch**\\r\\n\\r\\nPurpose: Read a byte from any RAM or ROM bank  \\r\\nCall address: $FF74  \\r\\nCommunication registers: .A .X .Y .P  \\r\\n\\r\\n**Description:** This function performs an \\u0060LDA (ZP),Y\\u0060 from any RAM or ROM bank. The the zero page address containing the base address is passed in .A, the bank in .X and the offset from the vector in .Y. The data byte is returned in .A. The flags are set according to .A, .X is destroyed, but .Y is preserved.\\r\\n\\r\\n\",\"stash\":\"**stash**\\r\\n\\r\\nPurpose: Write a byte to any RAM bank  \\r\\nCall address: $FF77  \\r\\nCommunication registers: .A .X .Y  \\r\\n\\r\\n**Description:** This function performs an \\u0060STA (ZP),Y\\u0060 to any RAM bank. The the zero page address containing the base address is passed in \\u0060stavec\\u0060 ($03B2), the bank in .X and the offset from the vector in .Y. After the call, .X is destroyed, but .A and .Y are preserved.\\r\\n\\r\\n\",\"MEMTOP\":\"**MEMTOP**\\r\\n\\r\\nPurpose: Get/Set top of RAM, number of usable RAM banks.  \\r\\nCall address: $FF99  \\r\\nCommunication registers: .A .X .Y .P (Carry)  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** Original C64 function which gets or\\r\\nsets the top of the usable address in RAM. On the X16,\\r\\nit additionally provides the number of RAM banks\\r\\navailable on the system and can even be used to set\\r\\nthis value after boot if desired.\\r\\n\\r\\nTo set the top of RAM, and the number of available banks, clear the carry flag.\\r\\n\\r\\nTo get the top of RAM and the number of available\\r\\nbanks, set carry flag.\\r\\n\\r\\nNote that the number of RAM banks is for informational\\r\\npurposes or for use by other programs. The KERNAL\\r\\ndoes not use this value itself.\\r\\n\\r\\n**Getting the number of usable RAM banks:**\\r\\n\\r\\nOn the X16, calling MEMTOP with the carry flag set\\r\\nwill return the number of available RAM banks on\\r\\nthe system in A. For example:\\r\\n\\r\\n\\u0060\\u0060\\u0060asm\\r\\n  sec\\r\\n  jsr MEMTOP\\r\\n  sta zp_NUM_BANKS\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\nIf the system has 512k of banked RAM, zp_NUM_BANKS\\r\\nwill contain \\\\$40 (64). For 1024k, \\\\$80; for 1536k, \\\\$C0.\\r\\nFor 2048k, the result will be \\\\$00 (which can be thought\\r\\nof as \\\\$100, or 256). It is possible to have other\\r\\nvalues (e.g. \\\\$42), such as if the system has bad\\r\\nbanked RAM.\\r\\n\\r\\n**Setting the top of BASIC RAM**\\r\\n\\r\\nThis routine changes the top of memory, allowing you to save a small machine\\r\\nlanguage routine at the top of BASIC RAM, just below the I/O space:\\r\\n\\r\\n\\u0060\\u0060\\u0060BASIC\\r\\n10 POKE$30F,1:SYS$FF99\\r\\n20 Y=$8C:X=$00\\r\\n30 POKE$30D,X:POKE$30E,Y:POKE$30F,0:SYS$FF99\\r\\n40 CLR\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\nAnalysis: \\r\\n\\r\\nThe SYS command uses memory locations \\\\$30C-\\\\$30F to pre-load the CPU registers,\\r\\nit then dumps the registers back to these locations after the SYS call is\\r\\ncomplete. \\\\$30D is the X register, \\\\$30E is .Y, and \\\\$30F is the flags. The Carry\\r\\nflag is bit 0, so setting $30F to 1 before calling MEMTOP indicates that this is\\r\\na _read_ of the values. \\r\\n\\r\\n1. Line 10 reads the current values. Do this to preserve the extended RAM bank\\r\\n   count.\\r\\n2. Line 20 uses the X and Y variables to make the code easier to read. Set Y to\\r\\n   the high byte of the address and X to the low byte. \\r\\n3. Line 30 POKEs those values in, clears the Carry bit ($30F is now 0), and\\r\\n   calls MEMTOP again.\\r\\n4. Finally, use CLR to lock in the new values. Since this clears all the\\r\\n   variables, you should _probably_ do this at the top of your program.\\r\\n\\r\\nThe address entered is actually the first byte of free space _after_\\r\\nyour BASIC program space, so if you set MEMTOP to \\\\$9C00, then you can start your\\r\\nassembly program at \\\\$9C00 with \\u0060* = $9C00\\u0060 or \\u0060org $9c00\\u0060.\\r\\n\\r\\nTo reserve 256 bytes, set X to \\\\$9E. To reserve 1KB, set X to \\\\$9C. To return to\\r\\nthe default values, set Y=\\\\$9F and X=0.\\r\\n\\r\\n\",\"clock_set_date_time\":\"**clock_set_date_time**\\r\\n\\r\\nPurpose: Set the date and time  \\r\\nCall address: $FF4D  \\r\\nCommunication registers: r0 r1 r2 r3  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** The routine \\u0060clock_set_date_time\\u0060 sets the system\\u0027s real-time-clock.\\r\\n\\r\\n| Register | Contents          |\\r\\n|----------|-------------------|\\r\\n| r0L      | year (1900-based) |\\r\\n| r0H      | month (1-12)      |\\r\\n| r1L      | day (1-31)        |\\r\\n| r1H      | hours (0-23)      |\\r\\n| r2L      | minutes (0-59)    |\\r\\n| r2H      | seconds (0-59)    |\\r\\n| r3L      | jiffies (0-59)    |\\r\\n| r3H      | weekday (1-7)     |\\r\\n\\r\\nJiffies are 1/60th seconds.\\r\\n\\r\\n\",\"clock_get_date_time\":\"**clock_get_date_time**\\r\\n\\r\\nPurpose: Get the date and time  \\r\\nCall address: $FF50  \\r\\nCommunication registers: r0 r1 r2 r3  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** The routine \\u0060clock_get_date_time\\u0060 returns the state of the system\\u0027s real-time-clock. The register assignment is identical to \\u0060clock_set_date_time\\u0060.\\r\\n\\r\\nOn the Commander X16, the _jiffies_ field is unsupported and will always read back as 0.\\r\\n\\r\\n\",\"RDTIM\":\"**RDTIM**\\r\\n\\r\\nPurpose: Read system clock  \\r\\nCall address: $FFDE  \\r\\nCommunication registers: .A .X .Y  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** Original C64 function which reads the system clock.  The clock\\u0027s resolution is a 60th of a second.  Three bytes are returned by the routine.  The accumulator contains the least significant byte, the X index register contains the next most significant byte, and the Y index register contains the the most significant byte.\\r\\n\\r\\nThe behavior of this Kernal routine is the same on the X16 and C64 despite errors in the _Commodore 64 Programmer\\u0027s Reference Guide_ and some other period books which incorrectly describe the order/significance of the resulting bytes in the registers.\\r\\n\\r\\n**EXAMPLE**:\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\njsr RDTIM\\r\\nsta STARTTIME    ; least significant byte\\r\\nstx STARTTIME\\u002B1\\r\\nsty STARTTIME\\u002B2  ; most significant byte\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"kbdbuf_peek\":\"**kbdbuf_peek**\\r\\n\\r\\nPurpose: Get next char and keyboard queue length  \\r\\nCall address: $FEBD  \\r\\nCommunication registers: .A .X  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: -  \\r\\n\\r\\n**Description:** The routine \\u0060kbdbuf_peek\\u0060 returns the next character in the keyboard queue in .A, without removing it from the queue, and the current length of the queue in .X. If .X is 0, the Z flag will be set, and the value of .A is undefined.\\r\\n\\r\\n\",\"kbdbuf_get_modifiers\":\"**kbdbuf_get_modifiers**\\r\\n\\r\\nPurpose: Get currently pressed modifiers  \\r\\nCall address: $FEC0  \\r\\nCommunication registers: .A  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: -  \\r\\n\\r\\n**Description:** The routine \\u0060kbdbuf_get_modifiers\\u0060 returns a bitmask that represents the currently pressed modifier keys in .A:\\r\\n\\r\\n| Bit | Value | Description  | Comment        |\\r\\n|-----|-------|--------------|----------------|\\r\\n| 0   | 1     | Shift        |                |\\r\\n| 1   | 2     | Alt          | C64: Commodore |\\r\\n| 2   | 4     | Control      |                |\\r\\n| 3   | 8     | Logo/Windows | C128: Alt      |\\r\\n| 4   | 16    | Caps         |                |\\r\\n\\r\\nThis allows detecting combinations of a regular key and a modifier key in cases where there is no dedicated PETSCII code for the combination, e.g. Ctrl\\u002BEsc or Alt\\u002BF1.\\r\\n\\r\\n\",\"kbdbuf_put\":\"**kbdbuf_put**\\r\\n\\r\\nPurpose: Append a char to the keyboard queue  \\r\\nCall address: $FEC3  \\r\\nCommunication registers: .A  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .X  \\r\\n\\r\\n**Description:** The routine \\u0060kbdbuf_put\\u0060 appends the char in .A to the keyboard queue.\\r\\n\\r\\n\",\"keymap\":\"**keymap**\\r\\n\\r\\nPurpose: Set or get the current keyboard layout\\r\\nCall address: $FED2  \\r\\nCommunication registers: .X .Y  \\r\\nPreparatory routines: None  \\r\\nError returns: c = 1 in case of error  \\r\\nRegisters affected: -  \\r\\n\\r\\n**Description:** If c is set, the routine \\u0060keymap\\u0060 returns a pointer to a zero-terminated string with the current keyboard layout identifier in .X/.Y. If c is clear, it sets the keyboard layout to the zero-terminated identifier pointed to by .X/.Y. On return, c is set in case the keyboard layout is unsupported.\\r\\n\\r\\nKeyboard layout identifiers are in the form \\u0022DE\\u0022, \\u0022DE-CH\\u0022 etc.\\r\\n\\r\\n\",\"kbd_scan\":\"**kbd_scan**\\r\\n\\r\\nAlso Known As: SCNKEY  \\r\\nPurpose: Read a keycode previously fetched from the SMC, apply keymap localization, and add it to the X16\\u0027s buffer.  \\r\\nCall address: $FF9F  \\r\\nCommunication registers: None  \\r\\nPreparatory routines: \\u0060ps2data_fetch\\u0060  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:**\\r\\n\\r\\nThis routine is called by the default KERNAL IRQ hancler in order to process a keystroke previously fetched by \\u0060ps2data_fetch\\u0060, translate it to the appropriate localized PETSCII or ISO code based on the configured layout, and place it in the KERNAL\\u0027s keyboard buffer.\\r\\n\\r\\nUnless the KERNAL IRQ handler is being bypassed or supplemented, it is not normally necessary to call this routine from user code, as both \\u0060ps2data_fetch\\u0060 and \\u0060kbd_scan\\u0060 are both run inside the default IRQ handler.  \\r\\n\\r\\n\",\"mouse_config\":\"**mouse_config**\\r\\n\\r\\nPurpose: Configure the mouse pointer  \\r\\nCall address: $FF68  \\r\\nCommunication registers: .A .X .Y  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** The routine \\u0060mouse_config\\u0060 configures the mouse pointer.\\r\\n\\r\\nThe argument in .A specifies whether the mouse pointer should be visible or not, and what shape it should have. For a list of possible values, see the basic statement [MOUSE](X16%20Reference%20-%2004%20-%20BASIC.md#mouse).\\r\\n\\r\\nThe arguments in .X and .Y specify the screen resolution in 8 pixel increments. The values .X = 0 and .Y = 0 keep the current resolution.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n SEC\\r\\n JSR screen_mode ; get current screen size (in 8px) into .X and .Y\\r\\n LDA #1\\r\\n JSR mouse_config ; show the default mouse pointer\\r\\n\\r\\n\",\"mouse_scan\":\"**mouse_scan**\\r\\n\\r\\nPurpose: Query the mouse and save its state  \\r\\nCall address: $FF71  \\r\\nCommunication registers: None  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** The routine \\u0060mouse_scan\\u0060 retrieves all state from the mouse and saves it. It can then be retrieved using \\u0060mouse_get\\u0060. The default interrupt handler already takes care of this, so this routine should only be called if the interrupt handler has been completely replaced.\\r\\n\\r\\n\",\"mouse_get\":\"**mouse_get**\\r\\n\\r\\nPurpose: Get the mouse state  \\r\\nCall address: $FF6B  \\r\\nCommunication registers: .X  \\r\\nPreparatory routines: \\u0060mouse_config\\u0060  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X  \\r\\n\\r\\n**Description:** The routine \\u0060mouse_get\\u0060 returns the state of the mouse. The caller passes the offset of a zero-page location in .X, which the routine will populate with the mouse position in 4 consecutive bytes:\\r\\n\\r\\n| Offset | Size | Description |\\r\\n|--------|------|-------------|\\r\\n| 0      | 2    | X Position  |\\r\\n| 2      | 2    | Y Position  |\\r\\n\\r\\nThe state of the mouse buttons is returned in the .A register:\\r\\n\\r\\n| Bit | Description    |\\r\\n|-----|----------------|\\r\\n| 0   | Left Button    |\\r\\n| 1   | Right Button   |\\r\\n| 2   | Middle Button  |\\r\\n| 3   | Unused         |\\r\\n| 4   | Button 4       |\\r\\n| 5   | Button 5       |\\r\\n\\r\\nIf a button is pressed, the corresponding bit is set. Buttons 4 and 5 are extended buttons not supported by all mice.\\r\\n\\r\\nIf available, the movement of the scroll wheel since the last call to this function is returned in the .X register as an 8-bit signed value. Moving the scroll wheel away from the user is represented\\r\\nby a negative value, and moving it towards the user is represented by a positive value. If the connected mouse has no scroll wheel, the value 0 is returned in the .X register.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\nLDX #$70\\r\\nJSR mouse_get ; get mouse position in $70/$71 (X) and $72/$73 (Y)\\r\\nAND #1\\r\\nBNE BUTTON_PRESSED\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"joystick_scan\":\"**joystick_scan**\\r\\n\\r\\nPurpose: Query the joysticks and save their state  \\r\\nCall address: $FF53  \\r\\nCommunication registers: None  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** The routine \\u0060joystick_scan\\u0060 retrieves all state from the four joysticks and saves it. It can then be retrieved using \\u0060joystick_get\\u0060. The default interrupt handler already takes care of this, so this routine should only be called if the interrupt handler has been completely replaced.\\r\\n\\r\\n\",\"joystick_get\":\"**joystick_get**\\r\\n\\r\\nPurpose: Get the state of one of the joysticks  \\r\\nCall address: $FF56  \\r\\nCommunication registers: .A  \\r\\nPreparatory routines: \\u0060joystick_scan\\u0060  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** The routine \\u0060joystick_get\\u0060 retrieves all state from one of the joysticks. The number of the joystick is passed in .A (0 for the keyboard joystick and 1 through 4 for SNES controllers), and the state is returned in .A, .X and .Y.\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\n      .A, byte 0:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\\r\\n                  SNES | B | Y |SEL|STA|UP |DN |LT |RT |\\r\\n\\r\\n      .X, byte 1:      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\\r\\n                  SNES | A | X | L | R | 1 | 1 | 1 | 1 |\\r\\n      .Y, byte 2:\\r\\n                  $00 = joystick present\\r\\n                  $FF = joystick not present\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\nIf a button is pressed, the corresponding bit is zero.\\r\\n\\r\\n(With a dedicated handler, the API can also be used for other devices with an SNES controller connector. The data returned in .A/.X/Y is just the raw 24 bits returned by the device.)\\r\\n\\r\\nThe keyboard joystick uses the standard SNES9X/ZSNES mapping:\\r\\n\\r\\n| SNES Button    |Keyboard Key  | Alt. Keyboard Key |\\r\\n|----------------|--------------|-------------------|\\r\\n| A              | X            | Left Ctrl         |\\r\\n| B              | Z            | Left Alt          |\\r\\n| X              | S            |                   |\\r\\n| Y              | A            |                   |\\r\\n| L              | D            |                   |\\r\\n| R              | C            |                   |\\r\\n| START          | Enter        |                   |\\r\\n| SELECT         | Left Shift   |                   |\\r\\n| D-Pad          | Cursor Keys  |                   |\\r\\n\\r\\nNote that the keyboard joystick will allow LEFT and RIGHT as well as UP and DOWN to be pressed at the same time, while controllers usually prevent this mechanically.\\r\\n\\r\\n**How to Use:**\\r\\n\\r\\nIf the default interrupt handler is used:\\r\\n\\r\\n1) Call this routine.\\r\\n\\r\\nIf the default interrupt handler is disabled or replaced:\\r\\n\\r\\n1) Call \\u0060joystick_scan\\u0060 to have the system query the joysticks.\\r\\n2) Call this routine.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\n      JSR joystick_scan\\r\\n      LDA #0\\r\\n      JSR joystick_get\\r\\n      TXA\\r\\n      AND #128\\r\\n      BEQ A_PRESSED\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"i2c_batch_read\":\"**i2c_batch_read**\\r\\n\\r\\nPurpose: Read bytes from a given I2C device into a RAM location  \\r\\nCall address: $FEB4  \\r\\nCommunication registers: .X r0 r1 c  \\r\\nPreparatory routines: None  \\r\\nError returns: c = 1 in case of error  \\r\\nRegisters affected: .A .Y .P  \\r\\n\\r\\n**Description:** The routine \\u0060i2c_batch_read\\u0060 reads a fixed number of bytes from an I2C device into RAM.  To call, put I2C device (address) in .X, the pointer to the RAM location to which to place the data into r0, and the number of bytes to read into r1.  If carry is set, the RAM location isn\\u0027t advanced.  This might be useful if you\\u0027re reading from an I2C device and writing directly into VRAM.\\r\\n\\r\\nIf the routine encountered an error, carry will be set upon return.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\nldx #$50 ; One of the cartridge I2C flash devices\\r\\nlda #\\u003C$0400\\r\\nsta r0\\r\\nlda #\\u003E$0400\\r\\nsta r0\\u002B1\\r\\nlda #\\u003C500\\r\\nsta r1\\r\\nlda #\\u003E500\\r\\nsta r1\\u002B1\\r\\nclc\\r\\njsr i2c_batch_read ; read 500 bytes from I2C device $50 into RAM starting at $0400\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"i2c_batch_write\":\"**i2c_batch_write**\\r\\n\\r\\nPurpose: Write bytes to a given I2C device with data in RAM  \\r\\nCall address: $FEB7  \\r\\nCommunication registers: .X r0 r1 r2 c  \\r\\nPreparatory routines: None  \\r\\nError returns: c = 1 in case of error  \\r\\nRegisters affected: .A .Y .P r2  \\r\\n\\r\\n**Description:** The routine \\u0060i2c_batch_write\\u0060 writes a fixed number of bytes from RAM to an I2C device.  To call, put I2C device (address) in .X, the pointer to the RAM location from which to read into r0, and the number of bytes to write into r1.  If carry is set, the RAM location isn\\u0027t advanced.  This might be useful if you\\u0027re reading from an I/O device and writing that data to an I2C device.\\r\\n\\r\\nThe number of bytes written is returned in r2. If the routine encountered an error, carry will be set upon return.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\nldx #$50 ; One of the cartridge I2C flash devices\\r\\nlda #\\u003C$0400\\r\\nsta r0\\r\\nlda #\\u003E$0400\\r\\nsta r0\\u002B1\\r\\nlda #\\u003C500\\r\\nsta r1\\r\\nlda #\\u003E500\\r\\nsta r1\\u002B1\\r\\nclc\\r\\njsr i2c_batch_write ; write 500 bytes to I2C device $50 from RAM\\r\\n                    ; starting at $0400 \\r\\n                    ; for this example, the first two bytes in\\r\\n                    ; the $0400 buffer would be the target address\\r\\n                    ; in the I2C flash. This, of course, varies\\r\\n                    ; between various I2C device types.\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"i2c_read_byte\":\"**i2c_read_byte**\\r\\n\\r\\nPurpose: Read a byte at a given offset from a given I2C device  \\r\\nCall address: $FEC6  \\r\\nCommunication registers: .A .X .Y  \\r\\nPreparatory routines: None  \\r\\nError returns: c = 1 in case of error  \\r\\nRegisters affected: .A  \\r\\n\\r\\n**Description:** The routine \\u0060i2c_read_byte\\u0060 reads a single byte at offset .Y from I2C device .X and returns the result in .A. c is 0 if the read was successful, and 1 if no such device exists.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\nLDX #$6F ; RTC device\\r\\nLDY #$20 ; start of NVRAM inside RTC\\r\\nJSR i2c_read_byte ; read first byte of NVRAM\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"i2c_write_byte\":\"**i2c_write_byte**\\r\\n\\r\\nPurpose: Write a byte at a given offset to a given I2C device  \\r\\nCall address: $FEC9  \\r\\nCommunication registers: .A .X .Y  \\r\\nPreparatory routines: None  \\r\\nError returns: c = 1 in case of error  \\r\\nRegisters affected: .A .P  \\r\\n\\r\\n**Description:** The routine \\u0060i2c_write_byte\\u0060 writes the byte in .A at offset .Y of I2C device .X. c is 0 if the write was successful, and 1 if no such device exists.\\r\\n\\r\\n**EXAMPLES:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\nLDX #$6F ; RTC device\\r\\nLDY #$20 ; start of NVRAM inside RTC\\r\\nLDA #\\u0027X\\u0027\\r\\nJSR i2c_write_byte ; write first byte of NVRAM\\r\\n\\r\\nLDX #$42 ; System Management Controller\\r\\nLDY #$01 ; magic location for system poweroff\\r\\nLDA #$00 ; magic value for system poweroff\\r\\nJSR i2c_write_byte ; power off the system\\r\\n\\r\\n; Reset system at the end of your program\\r\\nLDX #$42  ; System Management Controller\\r\\nLDY #$02  ; magic location for system reset\\r\\nLDA #$00  ; magic value for system poweroff/reset\\r\\nJSR $FEC9 ; reset the computer\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"sprite_set_image\":\"**sprite_set_image**\\r\\n\\r\\nPurpose: Set the image of a sprite  \\r\\nCall address: $FEF0  \\r\\nSignature: bool sprite_set_image(byte number: .A, width: .X, height: .Y, apply_mask: c, word pixels: r0, word mask: r1, byte bpp: r2L);  \\r\\nError returns: c = 1 in case of error\\r\\n\\r\\n**Description:** This function sets the image of a sprite. The number of the sprite is given in .A, The bits per pixel (bpp) in r2L, and the width and height in .X and .Y. The pixel data at r0 is interpreted accordingly and converted into the graphics hardware\\u0027s native format. If the c flag is set, the transparency mask pointed to by r1 is applied during the conversion. The function returns c = 0 if converting the data was successful, and c = 1 otherwise. Note that this does not change the visibility of the sprite.\\r\\n\\r\\n**Note**: There are certain limitations on the possible values of width, height, bpp and apply_mask:\\r\\n\\r\\n* width and height may not exceed the hardware\\u0027s capabilities.\\r\\n* Legal values for bpp are 1, 4 and 8. If the hardware only supports lower depths, the image data is converted down.\\r\\n* apply_mask is only valid for 1 bpp data.\\r\\n\\r\\n\",\"sprite_set_position\":\"**sprite_set_position**\\r\\n\\r\\nPurpose: Set the position of a sprite or hide it.  \\r\\nCall address: $FEF3  \\r\\nSignature: void sprite_set_position(byte number: .A, word x: r0, word y: r1);  \\r\\nError returns: None\\r\\n\\r\\n**Description:** This function shows a given sprite (.A) at a certain position or hides it. The position is passed in r0 and r1. If the x position is negative (\\u0026gt;$8000), the sprite will be hidden.\\r\\n\\r\\n**Note**: This routine only supports setting the position for sprite numbers 0-31.\\r\\n\\r\\n\",\"FB_init\":\"**FB_init**\\r\\n\\r\\nSignature: void FB_init();  \\r\\nPurpose: Enter graphics mode.\\r\\n\\r\\nThe default driver for this call activates VERA layer 0 without changing the state of any other VERA layers.  If layer 1 (such as the KERNAL text layer) is active and opaque, it may occlude layer 0 entirely.\\r\\n\\r\\n\",\"FB_get_info\":\"**FB_get_info**\\r\\n\\r\\nSignature: void FB_get_info(out word width: r0, out word height: r1, out byte color_depth: .A);  \\r\\nPurpose: Return the resolution and color depth\\r\\n\\r\\n\",\"FB_set_palette\":\"**FB_set_palette**\\r\\n\\r\\nSignature: void FB_set_palette(word pointer: r0, index: .A, color count: .X);  \\r\\nPurpose: Set (parts of) the palette\\r\\n\\r\\n**Description:** \\u0060FB_set_palette\\u0060 copies color data from the address pointed to by r0, updates the color in VERA palette RAM starting at the index A, with the length of the update (in words) in X.  If X is 0, all 256 colors are copied (512 bytes)\\r\\n\\r\\n\",\"FB_cursor_position\":\"**FB_cursor_position**\\r\\n\\r\\nSignature: void FB_cursor_position(word x: r0, word y: r1);  \\r\\nPurpose: Position the direct-access cursor\\r\\n\\r\\n**Description:** \\u0060FB_cursor_position\\u0060 sets the direct-access cursor to the given screen coordinate. Future operations will access pixels at the cursor location and update the cursor.\\r\\n\\r\\n\",\"FB_cursor_next_line\":\"**FB_cursor_next_line**\\r\\n\\r\\nSignature: void FB_cursor_next_line(word x: r0);  \\r\\nPurpose: Move the direct-access cursor to next line\\r\\n\\r\\n**Description:** \\u0060FB_cursor_next_line\\u0060 increments the y position of the direct-access cursor, and sets the x position to the same one that was passed to the previous \\u0060FB_cursor_position\\u0060 call. This is useful for drawing rectangular shapes, and faster than explicitly positioning the cursor.\\r\\n\\r\\n\",\"FB_get_pixel\":\"**FB_get_pixel**\\r\\n\\r\\nSignature: byte FB_get_pixel();  \\r\\nPurpose: Read one pixel, update cursor\\r\\n\\r\\n\",\"FB_get_pixels\":\"**FB_get_pixels**\\r\\n\\r\\nSignature: void FB_get_pixels(word ptr: r0, word count: r1);  \\r\\nPurpose: Copy pixels into RAM, update cursor\\r\\n\\r\\n**Description:** This function copies pixels into an array in RAM. The array consists of one byte per pixel.\\r\\n\\r\\n\",\"FB_set_pixel\":\"**FB_set_pixel**\\r\\n\\r\\nSignature: void FB_set_pixel(byte color: .A);  \\r\\nPurpose: Set one pixel, update cursor\\r\\n\\r\\n\",\"FB_set_pixels\":\"**FB_set_pixels**\\r\\n\\r\\nSignature: void FB_set_pixels(word ptr: r0, word count: r1);  \\r\\nPurpose: Copy pixels from RAM, update cursor\\r\\n\\r\\n**Description:** This function sets pixels from an array of pixels in RAM. The array consists of one byte per pixel.\\r\\n\\r\\n\",\"FB_set_8_pixels\":\"**FB_set_8_pixels**\\r\\n\\r\\nSignature: void FB_set_8_pixels(byte pattern: .A, byte color: .X);  \\r\\nPurpose: Set 8 pixels from bit mask (transparent), update cursor\\r\\n\\r\\n**Description:** This function sets all 1-bits of the pattern to a given color and skips a pixel for every 0 bit. The order is MSB to LSB. The cursor will be moved by 8 pixels.\\r\\n\\r\\n\",\"FB_set_8_pixels_opaque\":\"**FB_set_8_pixels_opaque**\\r\\n\\r\\nSignature: void FB_set_8_pixels_opaque(byte pattern: .A, byte mask: r0L, byte color1: .X, byte color2: .Y);  \\r\\nPurpose: Set 8 pixels from bit mask (opaque), update cursor\\r\\n\\r\\n**Description:** For every 1-bit in the mask, this function sets the pixel to color1 if the corresponding bit in the pattern is 1, and to color2 otherwise. For every 0-bit in the mask, it skips a pixel. The order is MSB to LSB. The cursor will be moved by 8 pixels.\\r\\n\\r\\n\",\"FB_fill_pixels\":\"**FB_fill_pixels**\\r\\n\\r\\nSignature: void FB_fill_pixels(word count: r0, word step: r1, byte color: .A);  \\r\\nPurpose: Fill pixels with constant color, update cursor\\r\\n\\r\\n**Description:** \\u0060FB_fill_pixels\\u0060 sets pixels with a constant color. The argument \\u0060step\\u0060 specifies the increment between pixels. A value of 0 or 1 will cause consecutive pixels to be set. Passing a \\u0060step\\u0060 value of the screen width will set vertically adjacent pixels going top down. Smaller values allow drawing dotted horizontal lines, and multiples of the screen width allow drawing dotted vertical lines.\\r\\n\\r\\n\",\"FB_filter_pixels\":\"**FB_filter_pixels**\\r\\n\\r\\nSignature: void FB_filter_pixels(word ptr: r0, word count: r1);  \\r\\nPurpose: Apply transform to pixels, update cursor\\r\\n\\r\\n**Description:** This function allows modifying consecutive pixels. The function pointer will be called for every pixel, with the color in .A, and it needs to return the new color in .A.\\r\\n\\r\\n\",\"FB_move_pixels\":\"**FB_move_pixels**\\r\\n\\r\\nSignature: void FB_move_pixels(word sx: r0, word sy: r1, word tx: r2, word ty: r3, word count: r4);  \\r\\nPurpose: Copy horizontally consecutive pixels to a different position\\r\\n\\r\\n*[Note: Overlapping regions are not yet supported.]*\\r\\n\\r\\n\",\"GRAPH_init\":\"**GRAPH_init**\\r\\n\\r\\nSignature: void GRAPH_init(word vectors: r0);  \\r\\nPurpose: Activate framebuffer driver, enter and initialize graphics mode\\r\\n\\r\\n**Description**: This call activates the framebuffer driver whose vector table is passed in r0. If r0 is 0, the default driver is activated. It then switches the video hardware into graphics mode, sets the window to full screen, initializes the colors and activates the system font.\\r\\n\\r\\nThis function calls \\u0060FB_init\\u0060, whose default driver activates VERA layer 0 without changing the state of any other VERA layers.  If layer 1 (such as the KERNAL text layer) is active and opaque, it may occlude layer 0 entirely.\\r\\n\\r\\n\",\"GRAPH_clear\":\"**GRAPH_clear**\\r\\n\\r\\nSignature: void GRAPH_clear();  \\r\\nPurpose: Clear the current window with the current background color.\\r\\n\\r\\n\",\"GRAPH_set_window\":\"**GRAPH_set_window**\\r\\n\\r\\nSignature: void GRAPH_set_window(word x: r0, word y: r1, word width: r2, word height: r3);  \\r\\nPurpose: Set the clipping region\\r\\n\\r\\n**Description:** All graphics commands are clipped to the window. This function configures the origin and size of the window. All 0 arguments set the window to full screen.\\r\\n\\r\\n*[Note: Only text output and GRAPH_clear currently respect the clipping region.]*\\r\\n\\r\\n\",\"GRAPH_set_colors\":\"**GRAPH_set_colors**\\r\\n\\r\\nSignature: void GRAPH_set_colors(byte stroke: .A, byte fill: .X, byte background: .Y);  \\r\\nPurpose: Set the three colors\\r\\n\\r\\n**Description:** This function sets the three colors: The stroke color, the fill color and the background color.\\r\\n\\r\\n\",\"GRAPH_draw_line\":\"**GRAPH_draw_line**\\r\\n\\r\\nSignature: void GRAPH_draw_line(word x1: r0, word y1: r1, word x2: r2, word y2: r3);  \\r\\nPurpose: Draw a line using the stroke color\\r\\n\\r\\n\",\"GRAPH_draw_rect\":\"**GRAPH_draw_rect**\\r\\n\\r\\nSignature: void GRAPH_draw_rect(word x: r0, word y: r1, word width: r2, word height: r3, word corner_radius: r4, bool fill: c);  \\r\\nPurpose: Draw a rectangle.\\r\\n\\r\\n**Description:** This function will draw the frame of a rectangle using the stroke color. If \\u0060fill\\u0060 is \\u0060true\\u0060, it will also fill the area using the fill color. To only fill a rectangle, set the stroke color to the same value as the fill color.\\r\\n\\r\\n*[Note: The border radius is currently unimplemented.]*\\r\\n\\r\\n\",\"GRAPH_move_rect\":\"**GRAPH_move_rect**\\r\\n\\r\\nSignature: void GRAPH_move_rect(word sx: r0, word sy: r1, word tx: r2, word ty: r3, word width: r4, word height: r5);  \\r\\nPurpose: Copy a rectangular screen area to a different location\\r\\n\\r\\n**Description:** \\u0060GRAPH_move_rect\\u0060 coll copy a rectangular area of the screen to a different location. The two areas may overlap.\\r\\n\\r\\n*[Note: Support for overlapping is not currently implemented.]*\\r\\n\\r\\n\",\"GRAPH_draw_oval\":\"**GRAPH_draw_oval**\\r\\n\\r\\nSignature: void GRAPH_draw_oval(word x: r0, word y: r1, word width: r2, word height: r3, bool fill: c);  \\r\\nPurpose: Draw an oval or a circle\\r\\n\\r\\n**Description:** This function draws an oval filling the given bounding box. If width equals height, the resulting shape is a circle. The oval will be outlined by the stroke color. If \\u0060fill\\u0060 is \\u0060true\\u0060, it will be filled using the fill color. To only fill an oval, set the stroke color to the same value as the fill color.\\r\\n\\r\\n\",\"GRAPH_draw_image\":\"**GRAPH_draw_image**\\r\\n\\r\\nSignature: void GRAPH_draw_image(word x: r0, word y: r1, word ptr: r2, word width: r3, word height: r4);  \\r\\nPurpose: Draw a rectangular image from data in memory\\r\\n\\r\\n**Description:** This function copies pixel data from memory onto the screen. The representation of the data in memory has to have one byte per pixel, with the pixels organized line by line top to bottom, and within the line left to right.\\r\\n\\r\\n\",\"GRAPH_set_font\":\"**GRAPH_set_font**\\r\\n\\r\\nSignature: void GRAPH_set_font(void ptr: r0);  \\r\\nPurpose: Set the current font\\r\\n\\r\\n**Description:** This function sets the current font to be used for the remaining font-related functions. The argument is a pointer to the font data structure in memory, which must be in the format of a single point size GEOS font (i.e. one GEOS font file VLIR chunk). An argument of 0 will activate the built-in system font.\\r\\n\\r\\n\",\"GRAPH_get_char_size\":\"**GRAPH_get_char_size**\\r\\n\\r\\nSignature: (byte baseline: .A, byte width: .X, byte height_or_style: .Y, bool is_control: c) GRAPH_get_char_size(byte c: .A, byte format: .X);  \\r\\nPurpose: Get the size and baseline of a character, or interpret a control code\\r\\n\\r\\n**Description:** This functionality of \\u0060GRAPH_get_char_size\\u0060 depends on the type of code that is passed in: For a printable character, this function returns the metrics of the character in a given format. For a control code, it returns the resulting format. In either case, the current format is passed in .X, and the character in .A.\\r\\n\\r\\n* The format is an opaque byte value whose value should not be relied upon, except for \\u00600\\u0060, which is plain text.\\r\\n* The resulting values are measured in pixels.\\r\\n* The baseline is measured from the top.\\r\\n\\r\\n\",\"GRAPH_put_char\":\"**GRAPH_put_char**\\r\\n\\r\\nSignature: void GRAPH_put_char(inout word x: r0, inout word y: r1, byte c: .A);  \\r\\nPurpose: Print a character onto the graphics screen\\r\\n\\r\\n**Description:** This function prints a single character at a given location on the graphics screen. The location is then updated. The following control codes are supported:\\r\\n\\r\\n* $01: SWAP COLORS\\r\\n* $04: ATTRIBUTES: UNDERLINE\\r\\n* $06: ATTRIBUTES: BOLD\\r\\n* $07: BELL\\r\\n* $08: BACKSPACE\\r\\n* $09: TAB\\r\\n* $0A: LF\\r\\n* $0B: ATTRIBUTES: ITALICS\\r\\n* $0C: ATTRIBUTES: OUTLINE\\r\\n* \\\\$0D/\\\\$8D: REGULAR/SHIFTED RETURN\\r\\n* \\\\$11/\\\\$91: CURSOR: DOWN/UP\\r\\n* $12: ATTRIBUTES: REVERSE\\r\\n* \\\\$13/\\\\$93: HOME/CLEAR\\r\\n* $14 DEL\\r\\n* $92: ATTRIBUTES: CLEAR ALL\\r\\n* all color codes\\r\\n\\r\\nNotes:\\r\\n\\r\\n* CR (\\\\$0D) SHIFT\\u002BCR (\\\\$8D) and LF (\\\\$0A) all set the cursor to the beginning of the next line. The only difference is that CR and SHIFT\\u002BCR reset the attributes, and LF does not.\\r\\n* BACKSPACE (\\\\$08) and DEL (\\\\$14) move the cursor to the beginning of the previous character but does not actually clear it. Multiple consecutive BACKSPACE/DEL characters are not supported.\\r\\n* There is no way to individually disable attributes (underlined, bold, reversed, italics, outline). The only way to disable them is to reset the attributes using code $92, which switches to plain text.\\r\\n* All 16 PETSCII color codes are supported. Code $01 to swap the colors will swap the stroke and fill colors.\\r\\n* The stroke color is used to draw the characters, and the underline is drawn using the fill color. In reverse text mode, the text background is filled with the fill color.\\r\\n* *[BELL (\\\\$07), TAB (\\\\$09) and SHIFT\\u002BTAB (\\\\$18) are not yet implemented.]*\\r\\n\\r\\n\",\"console_init\":\"**console_init**\\r\\n\\r\\nSignature: void console_init(word x: r0, word y: r1, word width: r2, word height: r3);  \\r\\nPurpose: Initialize console mode.  \\r\\nCall address: $FEDB\\r\\n\\r\\n**Description:** This function initializes console mode. It sets up the window (text clipping area) passed into it, clears the window and positions the cursor at the top left. All 0 arguments create a full screen console. You have to switch to graphics mode using \\u0060screen_mode\\u0060 beforehand.\\r\\n\\r\\n\",\"console_put_char\":\"**console_put_char**\\r\\n\\r\\nSignature: void console_put_char(byte char: .A, bool wrapping: c);  \\r\\nPurpose: Print a character to the console.  \\r\\nCall address: $FEDE\\r\\n\\r\\n**Description:** This function prints a character to the console. The c flag specifies whether text should be wrapped at character (c=0) or word (c=1) boundaries. In the latter case, characters will be buffered until a SPACE, CR or LF character is sent, so make sure the text that is printed always ends in one of these characters.\\r\\n\\r\\n**Note**: If the bottom of the screen is reached, this function will scroll its contents up to make extra room.\\r\\n\\r\\n\",\"console_put_image\":\"**console_put_image**\\r\\n\\r\\nSignature: void console_put_image(word ptr: r0, word width: r1, word height: r2);  \\r\\nPurpose: Draw image as if it was a character.  \\r\\nCall address: $FED8\\r\\n\\r\\n**Description:** This function draws an image (in GRAPH_draw_image format) at the current cursor position and advances the cursor accordingly. This way, an image can be presented inline. A common example would be an emoji bitmap, but it is also possible to show full-width pictures if you print a newline before and after the image.\\r\\n\\r\\n**Notes**:\\r\\n\\r\\n* If the bottom of the screen is reached, this function will scroll its contents up to make extra room.\\r\\n* Subsequent line breaks will take the image height into account, so that the new cursor position is below the image.\\r\\n\\r\\n\",\"console_get_char\":\"**console_get_char**\\r\\n\\r\\nSignature: (byte char: .A) console_get_char();  \\r\\nPurpose: Get a character from the console.  \\r\\nCall address: $FEE1\\r\\n\\r\\n**Description:** This function gets a character to the console. It does this by collecting a whole line of character, i.e. until the user presses RETURN. Then, the line will be sent character by character.\\r\\n\\r\\nThis function allows editing the line using BACKSPACE/DEL, but does not allow moving the cursor within the line, write more than one line, or using control codes.\\r\\n\\r\\n\",\"console_set_paging_message\":\"**console_set_paging_message**\\r\\n\\r\\nSignature: void console_set_paging_message(word message: r0);  \\r\\nPurpose: Set the paging message or disable paging.  \\r\\nCall address: $FED5\\r\\n\\r\\n**Description:** The console can halt printing after a full screen height worth of text has been printed. It will then show a message, wait for any key, and continue printing. This function sets this message. A zero-terminated text is passed in r0. To turn off paging, call this function with r0 = 0 - this is the default.\\r\\n\\r\\n**Note:** It is possible to use control codes to change the text style and color. Do not use codes that change the cursor position, like CR or LF. Also, the text must not overflow one line on the screen.\\r\\n\\r\\n\",\"enter_basic\":\"**enter_basic**\\r\\n\\r\\nPurpose: Enter BASIC  \\r\\nCall address: $FF47  \\r\\nCommunication registers: .P  \\r\\nPreparatory routines: None  \\r\\nError returns: Does not return  \\r\\n\\r\\n**Description:** Call this to enter BASIC mode, either through a cold start (c=1) or a warm start (c=0).\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\nCLC\\r\\nJMP enter_basic ; returns to the \\u0022READY.\\u0022 prompt\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"entropy_get\":\"**entropy_get**\\r\\n\\r\\nPurpose: Get 24 random bits  \\r\\nCall address: $FECF  \\r\\nCommunication registers: .A .X .Y  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .A .X .Y  \\r\\n\\r\\n**Description:** This routine returns 24 somewhat random bits in registers .A, .X, and .Y. In order to get higher-quality random numbers, this data should be used to seed a pseudo-random number generator, as this is not a proper high quality pseudo-random number generator in and of itself.\\r\\n\\r\\n**How to Use:**\\r\\n\\r\\n1) Call this routine.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\n    ; throw a die\\r\\n    again:\\r\\n      JSR entropy_get\\r\\n      STX tmp   ; combine 24 bits\\r\\n      EOR tmp   ; using exclusive-or\\r\\n      STY tmp   ; to get a higher-quality\\r\\n      EOR tmp   ; 8 bit random value\\r\\n      STA tmp\\r\\n      LSR\\r\\n      LSR\\r\\n      LSR\\r\\n      LSR       ; combine resulting 8 bits\\r\\n      EOR tmp   ; to get 4 bits\\r\\n      AND #7    ; we\\u0027re down to values 0-7\\r\\n      CMP #0\\r\\n      BEQ again ; 0 is illegal\\r\\n      CMP #7\\r\\n      BEQ again ; 7 is illegal\\r\\n      ORA #$30  ; convert to ASCII\\r\\n      JMP $FFD2 ; print character\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"extapi\":\"**extapi**\\r\\nPurpose: Additional API functions  \\r\\nMinimum ROM version: R47  \\r\\nCall address: $FEAB  \\r\\nCommunication registers: .A .X .Y .P  \\r\\nPreparatory routines: None  \\r\\nError returns: Varies, but usually c=1  \\r\\nRegisters affected: Varies  \\r\\n\\r\\n**Description:** This API slot provides access to various extended calls. The call is selected by the .A register, and each call has its own register use and return behavior.\\r\\n\\r\\n| Call # | Name                  | Description                          | Inputs     | Outputs  | Preserves |\\r\\n| -------|-----------------------|--------------------------------------|------------|----------|-----------|\\r\\n| \\u0060$01\\u0060 | [\\u0060clear_status\\u0060](#extapi-function-name-clear_status) | resets the KERNAL IEC status to zero | none | none | - |\\r\\n| \\u0060$02\\u0060 | [\\u0060getlfs\\u0060](#extapi-function-name-getlfs) | getter counterpart to setlfs | none | .A .X .Y | - |\\r\\n| \\u0060$03\\u0060 | [\\u0060mouse_sprite_offset\\u0060](#extapi-function-name-mouse_sprite_offset) | get or set mouse sprite pixel offset | r0 r1 .P | r0 r1 | - |\\r\\n| \\u0060$04\\u0060 | [\\u0060joystick_ps2_keycodes\\u0060](#extapi-function-name-joystick_ps2_keycodes) | get or set joy0 keycode mappings | r0L-r6H .P | r0L-r6H  | - |\\r\\n| \\u0060$05\\u0060 | [\\u0060iso_cursor_char\\u0060](#extapi-function-name-iso_cursor_char) | get or set the ISO mode cursor char | .X .P | .X | - |\\r\\n| \\u0060$06\\u0060 | [\\u0060ps2kbd_typematic\\u0060](#extapi-function-name-ps2kbd_typematic) | set the keyboard repeat delay and rate | .X | - | - |\\r\\n| \\u0060$07\\u0060 | [\\u0060pfkey\\u0060](#extapi-function-name-pfkey) | program macros for F1-F8 and the RUN key | .X | - | - |\\r\\n| \\u0060$08\\u0060 | [\\u0060ps2data_fetch\\u0060](#extapi-function-name-ps2data_fetch) | Polls the SMC for PS/2 keyboard and mouse data | - | - | - |\\r\\n| \\u0060$09\\u0060 | [\\u0060ps2data_raw\\u0060](#extapi-function-name-ps2data_raw) | If the most recent \\u0060ps2data_fetch\\u0060 received a mouse packet or keycode, returns its raw value | - | .A .Y .X .P r0L-r1H | - |\\r\\n| \\u0060$0A\\u0060 | [\\u0060cursor_blink\\u0060](#extapi-function-name-cursor_blink) | Blinks or un-blinks the KERNAL editor cursor if appropriate | - | - | - |\\r\\n| \\u0060$0B\\u0060 | [\\u0060led_update\\u0060](#extapi-function-name-led_update) | Illuminates or clears the SMC activity LED based on disk activity or error status | - | - | - |\\r\\n| \\u0060$0C\\u0060 | [\\u0060mouse_set_position\\u0060](#extapi-function-name-mouse_set_position) | Moves the mouse cursor to a specific X/Y location | .X (.X)-(.X\\u002B3) | - | - |\\r\\n| \\u0060$0D\\u0060 | [\\u0060scnsiz\\u0060](#extapi-function-name-scnsiz) | Directly sets the kernal editor text dimensions | .X .Y | - | - |\\r\\n| \\u0060$0E\\u0060 | [\\u0060kbd_leds\\u0060](#extapi-function-name-kbd_leds) | Set or get the state of the PS/2 keyboard LEDs | .X .P | .X | - |\\r\\n| \\u0060$0F\\u0060 | [\\u0060memory_decompress_from_func\\u0060](#extapi-function-name-memory_decompress_from_func) | Decompresses LZSA2 data streamed by a function | r1 r4 | r1 | r4 |\\r\\n| \\u0060$10\\u0060 | [\\u0060default_palette\\u0060](#extapi-function-name-default_palette) | Get or upload the default palette | .P | .A .X .Y | - |\\r\\n\\r\\n\\r\\n\",\"monitor\":\"**monitor**\\r\\n\\r\\nPurpose: Enter the machine language monitor  \\r\\nCall address: $FECC  \\r\\nCommunication registers: None  \\r\\nPreparatory routines: None  \\r\\nError returns: Does not return  \\r\\nRegisters affected: Does not return\\r\\n\\r\\n**Description:** This routine switches from BASIC to machine language monitor mode. It does not return to the caller. When the user quits the monitor, it will restart BASIC.\\r\\n\\r\\n**How to Use:**\\r\\n\\r\\n1) Call this routine.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\n      JMP monitor\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"SCREEN\":\"**SCREEN**\\r\\n\\r\\nPurpose: Get the text resolution of the screen  \\r\\nCall address: $FFED  \\r\\nCommunication registers: .X, .Y  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: .A, .X, .Y, .P\\r\\n\\r\\n**Description:** This routine returns the KERNAL screen editor\\u0027s view of the text resolution. The column count is returned in .X and the row count is returned in .Y.\\r\\n\\r\\nIn contrast to calling [\\u0060screen_mode\\u0060](#function-name-screen_mode) with carry set, this function returns the configured resolution if ever it is updated by [\\u0060scnsiz\\u0060](#extapi-function-name-scnsiz). \\u0060screen_mode\\u0060 only returns the text dimensions the currently configured mode would have configured, ignoring any changes made by calls to \\u0060scnsiz\\u0060.\\r\\n\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\nSCREEN = $FFED\\r\\n\\r\\nget_res:\\r\\n        jsr SCREEN\\r\\n        sty my_rows\\r\\n        stx my_columns\\r\\n        rts\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"screen_mode\":\"**screen_mode**\\r\\n\\r\\nPurpose: Get/Set the screen mode  \\r\\nCall address: $FF5F  \\r\\nCommunication registers: .A, .X, .Y, .P  \\r\\nPreparatory routines: None  \\r\\nError returns: c = 1 in case of error  \\r\\nRegisters affected: .A, .X, .Y\\r\\n\\r\\n**Description:** If c is set, a call to this routine gets the current screen mode in .A, the width (in tiles) of the screen in .X, and the height (in tiles) of the screen in .Y. If c is clear, it sets the current screen mode to the value in .A. \\r\\nFor a list of possible values, see [Chapter 3: Editor](X16%20Reference%20-%2003%20-%20Editor.md#modes). If the mode is unsupported, c will be set, otherwise cleared.\\r\\n\\r\\nIf you use this function to get the text resolution instead of calling [\\u0060SCREEN\\u0060](#function-name-screen), this function only returns the text dimensions the currently configured mode would have set, ignoring any changes made by calls to [\\u0060scnsiz\\u0060](#extapi-function-name-scnsiz). If you want to fetch the KERNAL editor\\u0027s text resolution, call [\\u0060SCREEN\\u0060](#function-name-screen) instead.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\nLDA #$80\\r\\nCLC\\r\\nJSR screen_mode ; SET 320x240@256C MODE\\r\\nBCS FAILURE\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"screen_set_charset\":\"**screen_set_charset**\\r\\n\\r\\nPurpose: Activate a 8x8 text mode charset  \\r\\nCall address: $FF62\\r\\n\\r\\nCommunication registers: .A, .X, .Y  \\r\\nPreparatory routines: None  \\r\\nRegisters affected: .A, .X, .Y\\r\\n\\r\\n**Description:** A call to this routine uploads a character set to the video hardware and activates it. The value of .A decides what charset to upload:\\r\\n\\r\\n| Value | Description                     |\\r\\n|-------|---------------------------------|\\r\\n| 0     | use pointer in .X/.Y            |\\r\\n| 1     | ISO                             |\\r\\n| 2     | PET upper/graph                 |\\r\\n| 3     | PET upper/lower                 |\\r\\n| 4     | PET upper/graph (thin)          |\\r\\n| 5     | PET upper/lower (thin)          |\\r\\n| 6     | ISO (thin)                      |\\r\\n| 7     | CP437 (since r47)               |\\r\\n| 8     | Cyrillic ISO (since r47)        |\\r\\n| 9     | Cyrillic ISO (thin) (since r47) |\\r\\n| 10    | Eastern Latin ISO (since r47)   |\\r\\n| 11    | Eastern ISO (thin) (since r47)  |\\r\\n| 12    | Katakana (thin) (since r48)     |\\r\\n\\r\\nSee [Appendix I](X16%20Reference%20-%20Appendix%20I%20-%20Character%20Sets.md#appendix-i-character-sets)  \\r\\n\\r\\nIf .A is zero, .X (lo) and .Y (hi) contain a pointer to a 2 KB RAM area that gets uploaded as the new 8x8 character set. The data has to consist of 256 characters of 8 bytes each, top to bottom, with the MSB on the left, set bits (1) represent the foreground colored pixels.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\nLDA #0\\r\\nLDX #\\u003CMY_CHARSET\\r\\nLDY #\\u003EMY_CHARSET\\r\\nJSR screen_set_charset ; UPLOAD CUSTOM CHARSET \\u0022MY_CHARSET\\u0022\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n\",\"JSRFAR\":\"**JSRFAR**\\r\\n\\r\\nPurpose: Execute a routine on another RAM or ROM bank  \\r\\nCall address: $FF6E  \\r\\nCommunication registers: None  \\r\\nPreparatory routines: None  \\r\\nError returns: None  \\r\\nRegisters affected: None\\r\\n\\r\\n**Description:** The routine \\u0060JSRFAR\\u0060 enables code to execute some other code located on a specific RAM or ROM bank. This works independently of which RAM or ROM bank the currently executing code is residing in.\\r\\nThe 16 bit address and the 8 bit bank number have to follow the instruction stream. The \\u0060JSRFAR\\u0060 routine will switch both the ROM and the RAM bank to the specified bank and restore it after the routine\\u0027s \\u0060RTS\\u0060. Execution resumes after the 3 byte arguments.\\r\\n**Note**: The C128 also has a \\u0060JSRFAR\\u0060 function at $FF6E, but it is incompatible with the X16 version.\\r\\n\\r\\n**How to Use:**\\r\\n\\r\\n1) Call this routine.\\r\\n\\r\\n**EXAMPLE:**\\r\\n\\r\\n\\u0060\\u0060\\u0060ASM\\r\\n      JSR JSRFAR\\r\\n      .WORD $C000 ; ADDRESS\\r\\n      .BYTE 1     ; BANK\\r\\n\\u0060\\u0060\\u0060\\r\\n\\r\\n### 65C816 support\\r\\n\\r\\nWhen writing native 65C816 code for the Commander X16, extra care must be given when using the KERNAL API. With the exception of \\u0060extapi16\\u0060, documented below, the entire kernal API must be called:\\r\\n\\r\\n* With m=1, x=1 (accumulator and index are 8 bits)\\r\\n* SP set to the KERNAL stack ($01xx). see \\r\\n* DP=$0000 (must be set so that zeropage is the direct page)\\r\\n\\r\\n$FEA8: \\u0060extapi16\\u0060 - 16-bit extended API for 65C816 native mode  \\r\\n\\r\\n\",\"extapi16\":\"**extapi16**\\r\\n\\r\\nPurpose: API functions for 65C816  \\r\\nMinimum ROM version: R47  \\r\\nCall address: $FEA8  \\r\\nCommunication registers: .C, .X, .Y, .P  \\r\\nPreparatory routines: None  \\r\\nError returns: Varies, but usually c=1  \\r\\nRegisters affected: Varies\\r\\n\\r\\n**Description:** This API slot provides access to various native mode 65C816 calls. The call is selected by the .C register (accumulator), and each call has its own register use and return behavior.\\r\\n\\r\\n**IMPORTANT**  \\r\\n* All of the calls behind this API __must__ be called in native 65C816 mode, with m=0, .DP=$0000.\\r\\n* In addition, some of these __must__ be called with \\u0060rom_bank\\u0060 (zp address $01) set to bank 0 (the KERNAL bank) and not via KERNAL support in other ROM banks. If your program is launched from BASIC, the default bank is usually 4 until explicitly changed by your program.\\r\\n\\r\\n| Call # | Name           | Description                                 | Inputs | Outputs | Additional Prerequisites |\\r\\n| -------|----------------|---------------------------------------------|--------|---------|--------------------------|\\r\\n|  \\u0060$00\\u0060 | [\\u0060test\\u0060](#65c816-extapi16-function-name-test) | Used by unit tests | .X .Y  | .C | -                       |\\r\\n|  \\u0060$01\\u0060 | [\\u0060stack_push\\u0060](#65c816-extapi16-function-name-stack_push) | Switches to a new stack context | .X | none | x=0, $01=0 |\\r\\n|  \\u0060$02\\u0060 | [\\u0060stack_pop\\u0060](#65c816-extapi16-function-name-stack_pop) | Returns to the previous stack context | none | none | x=0, $01=0 |\\r\\n|  \\u0060$03\\u0060 | [\\u0060stack_enter_kernal_stack\\u0060](#65c816-extapi16-function-name-stack_enter_kernal_stack) | Switches to the $01xx stack | none | none | x=0, $01=0 |\\r\\n|  \\u0060$04\\u0060 | [\\u0060stack_leave_kernal_stack\\u0060](#65c816-extapi16-function-name-stack_leave_kernal_stack) | Returns to the previous stack context after \\u0060stack_enter_kernal_stack\\u0060 | none | none | x=0, $01=0 |\\r\\n\\r\\n\"}"));
    }
}